<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>plotman.interactive API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>plotman.interactive</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import curses
import datetime
import locale
import math
import os
import subprocess

from plotman import archive, configuration, manager, reporting
from plotman.job import Job


class TerminalTooSmallError(Exception):
    pass


class Log:
    def __init__(self):
        self.entries = []
        self.cur_pos = 0

    # TODO: store timestamp as actual timestamp indexing the messages
    def log(self, msg):
        &#39;&#39;&#39;Log the message and scroll to the end of the log&#39;&#39;&#39;
        ts = datetime.datetime.now().strftime(&#39;%m-%d %H:%M:%S&#39;)
        self.entries.append(ts + &#39; &#39; + msg)
        self.cur_pos = len(self.entries)

    def tail(self, num_entries):
        &#39;&#39;&#39;Return the entries at the end of the log.  Consider cur_slice() instead.&#39;&#39;&#39;
        return self.entries[-num_entries:]

    def shift_slice(self, offset):
        &#39;&#39;&#39;Positive shifts towards end, negative shifts towards beginning&#39;&#39;&#39;
        self.cur_pos = max(0, min(len(self.entries), self.cur_pos + offset))

    def shift_slice_to_end(self):
        self.cur_pos = len(self.entries)

    def get_cur_pos(self):
        return self.cur_pos

    def cur_slice(self, num_entries):
        &#39;&#39;&#39;Return num_entries log entries up to the current slice position&#39;&#39;&#39;
        return self.entries[max(0, self.cur_pos - num_entries): self.cur_pos]

    def fill_log(self):
        &#39;&#39;&#39;Add a bunch of stuff to the log.  Useful for testing.&#39;&#39;&#39;
        for i in range(100):
            self.log(&#39;Log line %d&#39; % i)


def plotting_status_msg(active, status):
    if active:
        return &#39;(active) &#39; + status
    else:
        return &#39;(inactive) &#39; + status


def archiving_status_msg(configured, active, status):
    if configured:
        if active:
            return &#39;(active) &#39; + status
        else:
            return &#39;(inactive) &#39; + status
    else:
        return &#39;(not configured)&#39;


def curses_main(stdscr):
    log = Log()

    cfg = configuration.get_validated_configs()
    plotting_active = True

    archiving_configured = cfg.directories.archive is not None
    archiving_active = archiving_configured

    plotting_status = &#39;&lt;startup&gt;&#39;  # todo rename these msg?
    archiving_status = &#39;&lt;startup&gt;&#39;

    stdscr.nodelay(True)  # make getch() non-blocking
    stdscr.timeout(2000)

    # Create windows.  We&#39;ll size them in the main loop when we have their content.
    header_win = curses.newwin(1, 1, 1, 0)
    log_win = curses.newwin(1, 1, 1, 0)
    jobs_win = curses.newwin(1, 1, 1, 0)
    dirs_win = curses.newwin(1, 1, 1, 0)

    jobs = Job.get_running_jobs(cfg.directories.log)
    last_refresh = None

    pressed_key = &#39;&#39;  # For debugging

    archdir_freebytes = None

    while True:

        # A full refresh scans for and reads info for running jobs from
        # scratch (i.e., reread their logfiles).  Otherwise we&#39;ll only
        # initialize new jobs, and mostly rely on cached info.
        do_full_refresh = False
        elapsed = 0  # Time since last refresh, or zero if no prev. refresh
        if last_refresh is None:
            do_full_refresh = True
        else:
            elapsed = (datetime.datetime.now() - last_refresh).total_seconds()
            do_full_refresh = elapsed &gt;= cfg.scheduling.polling_time_s

        if not do_full_refresh:
            jobs = Job.get_running_jobs(cfg.directories.log, cached_jobs=jobs)

        else:
            last_refresh = datetime.datetime.now()
            jobs = Job.get_running_jobs(cfg.directories.log)

            if plotting_active:
                (started, msg) = manager.maybe_start_new_plot(
                    cfg.directories, cfg.scheduling, cfg.plotting
                )
                if (started):
                    log.log(msg)
                    plotting_status = &#39;&lt;just started job&gt;&#39;
                    jobs = Job.get_running_jobs(cfg.directories.log, cached_jobs=jobs)
                else:
                    plotting_status = msg

            if archiving_configured:
                if archiving_active:
                    archiving_status, log_message = archive.spawn_archive_process(cfg.directories, jobs)
                    if log_message:
                        log.log(log_message)

                archdir_freebytes = archive.get_archdir_freebytes(cfg.directories.archive)

        # Get terminal size.  Recommended method is stdscr.getmaxyx(), but this
        # does not seem to work on some systems.  It may be a bug in Python
        # curses, maybe having to do with registering sigwinch handlers in
        # multithreaded environments.  See e.g.
        #     https://stackoverflow.com/questions/33906183#33906270
        # Alternative option is to call out to `stty size`.  For now, we
        # support both strategies, selected by a config option.
        # TODO: also try shutil.get_terminal_size()
        n_rows: int
        n_cols: int
        if cfg.user_interface.use_stty_size:
            completed_process = subprocess.run(
                [&#39;stty&#39;, &#39;size&#39;], check=True, encoding=&#39;utf-8&#39;, stdout=subprocess.PIPE
            )
            elements = completed_process.stdout.split()
            (n_rows, n_cols) = [int(v) for v in elements]
        else:
            (n_rows, n_cols) = map(int, stdscr.getmaxyx())

        stdscr.clear()
        stdscr.resize(n_rows, n_cols)
        curses.resize_term(n_rows, n_cols)

        #
        # Obtain and measure content
        #

        # Directory prefixes, for abbreviation
        tmp_prefix = os.path.commonpath(cfg.directories.tmp)
        dst_prefix = os.path.commonpath(cfg.directories.dst)
        if archiving_configured:
            arch_prefix = cfg.directories.archive.rsyncd_path

        n_tmpdirs = len(cfg.directories.tmp)
        n_tmpdirs_half = int(n_tmpdirs / 2)

        # Directory reports.
        tmp_report_1 = reporting.tmp_dir_report(
            jobs, cfg.directories, cfg.scheduling, n_cols, 0, n_tmpdirs_half, tmp_prefix)
        tmp_report_2 = reporting.tmp_dir_report(
            jobs, cfg.directories, cfg.scheduling, n_cols, n_tmpdirs_half, n_tmpdirs, tmp_prefix)
        dst_report = reporting.dst_dir_report(
            jobs, cfg.directories.dst, n_cols, dst_prefix)
        if archiving_configured:
            arch_report = reporting.arch_dir_report(archdir_freebytes, n_cols, arch_prefix)
            if not arch_report:
                arch_report = &#39;&lt;no archive dir info&gt;&#39;
        else:
            arch_report = &#39;&lt;archiving not configured&gt;&#39;

        #
        # Layout
        #

        tmp_h = max(len(tmp_report_1.splitlines()),
                    len(tmp_report_2.splitlines()))
        tmp_w = len(max(tmp_report_1.splitlines() +
                        tmp_report_2.splitlines(), key=len)) + 1
        dst_h = len(dst_report.splitlines())
        dst_w = len(max(dst_report.splitlines(), key=len)) + 1
        arch_h = len(arch_report.splitlines()) + 1
        arch_w = n_cols

        header_h = 3
        dirs_h = max(tmp_h, dst_h) + arch_h
        remainder = n_rows - (header_h + dirs_h)
        jobs_h = max(5, math.floor(remainder * 0.6))
        logs_h = n_rows - (header_h + jobs_h + dirs_h)

        header_pos = 0
        jobs_pos = header_pos + header_h
        stdscr.resize(n_rows, n_cols)
        dirs_pos = jobs_pos + jobs_h
        logscreen_pos = dirs_pos + dirs_h

        linecap = n_cols - 1
        logs_h = n_rows - (header_h + jobs_h + dirs_h)

        try:
            header_win = curses.newwin(header_h, n_cols, header_pos, 0)
            log_win = curses.newwin(logs_h, n_cols, logscreen_pos, 0)
            jobs_win = curses.newwin(jobs_h, n_cols, jobs_pos, 0)
            dirs_win = curses.newwin(dirs_h, n_cols, dirs_pos, 0)
        except Exception:
            raise Exception(&#39;Failed to initialize curses windows, try a larger &#39;
                            &#39;terminal window.&#39;)

        #
        # Write
        #

        # Header
        header_win.addnstr(0, 0, &#39;Plotman&#39;, linecap, curses.A_BOLD)
        timestamp = datetime.datetime.now().strftime(&#34;%H:%M:%S&#34;)
        refresh_msg = &#34;now&#34; if do_full_refresh else f&#34;{int(elapsed)}s/{cfg.scheduling.polling_time_s}&#34;
        header_win.addnstr(f&#34; {timestamp} (refresh {refresh_msg})&#34;, linecap)
        header_win.addnstr(&#39;  |  &lt;P&gt;lotting: &#39;, linecap, curses.A_BOLD)
        header_win.addnstr(
            plotting_status_msg(plotting_active, plotting_status), linecap)
        header_win.addnstr(&#39; &lt;A&gt;rchival: &#39;, linecap, curses.A_BOLD)
        header_win.addnstr(
            archiving_status_msg(archiving_configured,
                                 archiving_active, archiving_status), linecap)

        # Oneliner progress display
        header_win.addnstr(1, 0, &#39;Jobs (%d): &#39; % len(jobs), linecap)
        header_win.addnstr(&#39;[&#39; + reporting.job_viz(jobs) + &#39;]&#39;, linecap)

        # These are useful for debugging.
        # header_win.addnstr(&#39;  term size: (%d, %d)&#39; % (n_rows, n_cols), linecap)  # Debuggin
        # if pressed_key:
        # header_win.addnstr(&#39; (keypress %s)&#39; % str(pressed_key), linecap)
        header_win.addnstr(2, 0, &#39;Prefixes:&#39;, linecap, curses.A_BOLD)
        header_win.addnstr(&#39;  tmp=&#39;, linecap, curses.A_BOLD)
        header_win.addnstr(tmp_prefix, linecap)
        header_win.addnstr(&#39;  dst=&#39;, linecap, curses.A_BOLD)
        header_win.addnstr(dst_prefix, linecap)
        if archiving_configured:
            header_win.addnstr(&#39;  archive=&#39;, linecap, curses.A_BOLD)
            header_win.addnstr(arch_prefix, linecap)
        header_win.addnstr(&#39; (remote)&#39;, linecap)

        # Jobs
        jobs_win.addstr(0, 0, reporting.status_report(jobs, n_cols, jobs_h,
                                                      tmp_prefix, dst_prefix))
        jobs_win.chgat(0, 0, curses.A_REVERSE)

        # Dirs
        tmpwin_12_gutter = 3
        tmpwin_dstwin_gutter = 6

        maxtd_h = max([tmp_h, dst_h])

        tmpwin_1 = curses.newwin(
            tmp_h, tmp_w,
            dirs_pos + int((maxtd_h - tmp_h) / 2), 0)
        tmpwin_1.addstr(tmp_report_1)

        tmpwin_2 = curses.newwin(
            tmp_h, tmp_w,
            dirs_pos + int((maxtd_h - tmp_h) / 2),
            tmp_w + tmpwin_12_gutter)
        tmpwin_2.addstr(tmp_report_2)

        tmpwin_1.chgat(0, 0, curses.A_REVERSE)
        tmpwin_2.chgat(0, 0, curses.A_REVERSE)

        dstwin = curses.newwin(
            dst_h, dst_w,
            dirs_pos + int((maxtd_h - dst_h) / 2), 2 * tmp_w + tmpwin_12_gutter + tmpwin_dstwin_gutter)
        dstwin.addstr(dst_report)
        dstwin.chgat(0, 0, curses.A_REVERSE)

        archwin = curses.newwin(arch_h, arch_w, dirs_pos + maxtd_h, 0)
        archwin.addstr(0, 0, &#39;Archive dirs free space&#39;, curses.A_REVERSE)
        archwin.addstr(1, 0, arch_report)

        # Log.  Could use a pad here instead of managing scrolling ourselves, but
        # this seems easier.
        log_win.addnstr(0, 0, (&#39;Log: %d (&lt;up&gt;/&lt;down&gt;/&lt;end&gt; to scroll)\n&#39; % log.get_cur_pos()),
                        linecap, curses.A_REVERSE)
        for i, logline in enumerate(log.cur_slice(logs_h - 1)):
            log_win.addnstr(i + 1, 0, logline, linecap)

        stdscr.noutrefresh()
        header_win.noutrefresh()
        jobs_win.noutrefresh()
        tmpwin_1.noutrefresh()
        tmpwin_2.noutrefresh()
        dstwin.noutrefresh()
        archwin.noutrefresh()
        log_win.noutrefresh()
        curses.doupdate()

        try:
            key = stdscr.getch()
        except KeyboardInterrupt:
            key = ord(&#39;q&#39;)

        if key == curses.KEY_UP:
            log.shift_slice(-1)
            pressed_key = &#39;up&#39;
        elif key == curses.KEY_DOWN:
            log.shift_slice(1)
            pressed_key = &#39;dwn&#39;
        elif key == curses.KEY_END:
            log.shift_slice_to_end()
            pressed_key = &#39;end&#39;
        elif key == ord(&#39;p&#39;):
            plotting_active = not plotting_active
            pressed_key = &#39;p&#39;
        elif key == ord(&#39;a&#39;):
            archiving_active = not archiving_active
            pressed_key = &#39;a&#39;
        elif key == ord(&#39;q&#39;):
            break
        else:
            pressed_key = key


def run_interactive():
    locale.setlocale(locale.LC_ALL, &#39;&#39;)
    code = locale.getpreferredencoding()
    # Then use code as the encoding for str.encode() calls.

    try:
        curses.wrapper(curses_main)
    except curses.error as e:
        raise TerminalTooSmallError(
            &#34;Your terminal may be too small, try making it bigger.&#34;,
        ) from e</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="plotman.interactive.archiving_status_msg"><code class="name flex">
<span>def <span class="ident">archiving_status_msg</span></span>(<span>configured, active, status)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def archiving_status_msg(configured, active, status):
    if configured:
        if active:
            return &#39;(active) &#39; + status
        else:
            return &#39;(inactive) &#39; + status
    else:
        return &#39;(not configured)&#39;</code></pre>
</details>
</dd>
<dt id="plotman.interactive.curses_main"><code class="name flex">
<span>def <span class="ident">curses_main</span></span>(<span>stdscr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curses_main(stdscr):
    log = Log()

    cfg = configuration.get_validated_configs()
    plotting_active = True

    archiving_configured = cfg.directories.archive is not None
    archiving_active = archiving_configured

    plotting_status = &#39;&lt;startup&gt;&#39;  # todo rename these msg?
    archiving_status = &#39;&lt;startup&gt;&#39;

    stdscr.nodelay(True)  # make getch() non-blocking
    stdscr.timeout(2000)

    # Create windows.  We&#39;ll size them in the main loop when we have their content.
    header_win = curses.newwin(1, 1, 1, 0)
    log_win = curses.newwin(1, 1, 1, 0)
    jobs_win = curses.newwin(1, 1, 1, 0)
    dirs_win = curses.newwin(1, 1, 1, 0)

    jobs = Job.get_running_jobs(cfg.directories.log)
    last_refresh = None

    pressed_key = &#39;&#39;  # For debugging

    archdir_freebytes = None

    while True:

        # A full refresh scans for and reads info for running jobs from
        # scratch (i.e., reread their logfiles).  Otherwise we&#39;ll only
        # initialize new jobs, and mostly rely on cached info.
        do_full_refresh = False
        elapsed = 0  # Time since last refresh, or zero if no prev. refresh
        if last_refresh is None:
            do_full_refresh = True
        else:
            elapsed = (datetime.datetime.now() - last_refresh).total_seconds()
            do_full_refresh = elapsed &gt;= cfg.scheduling.polling_time_s

        if not do_full_refresh:
            jobs = Job.get_running_jobs(cfg.directories.log, cached_jobs=jobs)

        else:
            last_refresh = datetime.datetime.now()
            jobs = Job.get_running_jobs(cfg.directories.log)

            if plotting_active:
                (started, msg) = manager.maybe_start_new_plot(
                    cfg.directories, cfg.scheduling, cfg.plotting
                )
                if (started):
                    log.log(msg)
                    plotting_status = &#39;&lt;just started job&gt;&#39;
                    jobs = Job.get_running_jobs(cfg.directories.log, cached_jobs=jobs)
                else:
                    plotting_status = msg

            if archiving_configured:
                if archiving_active:
                    archiving_status, log_message = archive.spawn_archive_process(cfg.directories, jobs)
                    if log_message:
                        log.log(log_message)

                archdir_freebytes = archive.get_archdir_freebytes(cfg.directories.archive)

        # Get terminal size.  Recommended method is stdscr.getmaxyx(), but this
        # does not seem to work on some systems.  It may be a bug in Python
        # curses, maybe having to do with registering sigwinch handlers in
        # multithreaded environments.  See e.g.
        #     https://stackoverflow.com/questions/33906183#33906270
        # Alternative option is to call out to `stty size`.  For now, we
        # support both strategies, selected by a config option.
        # TODO: also try shutil.get_terminal_size()
        n_rows: int
        n_cols: int
        if cfg.user_interface.use_stty_size:
            completed_process = subprocess.run(
                [&#39;stty&#39;, &#39;size&#39;], check=True, encoding=&#39;utf-8&#39;, stdout=subprocess.PIPE
            )
            elements = completed_process.stdout.split()
            (n_rows, n_cols) = [int(v) for v in elements]
        else:
            (n_rows, n_cols) = map(int, stdscr.getmaxyx())

        stdscr.clear()
        stdscr.resize(n_rows, n_cols)
        curses.resize_term(n_rows, n_cols)

        #
        # Obtain and measure content
        #

        # Directory prefixes, for abbreviation
        tmp_prefix = os.path.commonpath(cfg.directories.tmp)
        dst_prefix = os.path.commonpath(cfg.directories.dst)
        if archiving_configured:
            arch_prefix = cfg.directories.archive.rsyncd_path

        n_tmpdirs = len(cfg.directories.tmp)
        n_tmpdirs_half = int(n_tmpdirs / 2)

        # Directory reports.
        tmp_report_1 = reporting.tmp_dir_report(
            jobs, cfg.directories, cfg.scheduling, n_cols, 0, n_tmpdirs_half, tmp_prefix)
        tmp_report_2 = reporting.tmp_dir_report(
            jobs, cfg.directories, cfg.scheduling, n_cols, n_tmpdirs_half, n_tmpdirs, tmp_prefix)
        dst_report = reporting.dst_dir_report(
            jobs, cfg.directories.dst, n_cols, dst_prefix)
        if archiving_configured:
            arch_report = reporting.arch_dir_report(archdir_freebytes, n_cols, arch_prefix)
            if not arch_report:
                arch_report = &#39;&lt;no archive dir info&gt;&#39;
        else:
            arch_report = &#39;&lt;archiving not configured&gt;&#39;

        #
        # Layout
        #

        tmp_h = max(len(tmp_report_1.splitlines()),
                    len(tmp_report_2.splitlines()))
        tmp_w = len(max(tmp_report_1.splitlines() +
                        tmp_report_2.splitlines(), key=len)) + 1
        dst_h = len(dst_report.splitlines())
        dst_w = len(max(dst_report.splitlines(), key=len)) + 1
        arch_h = len(arch_report.splitlines()) + 1
        arch_w = n_cols

        header_h = 3
        dirs_h = max(tmp_h, dst_h) + arch_h
        remainder = n_rows - (header_h + dirs_h)
        jobs_h = max(5, math.floor(remainder * 0.6))
        logs_h = n_rows - (header_h + jobs_h + dirs_h)

        header_pos = 0
        jobs_pos = header_pos + header_h
        stdscr.resize(n_rows, n_cols)
        dirs_pos = jobs_pos + jobs_h
        logscreen_pos = dirs_pos + dirs_h

        linecap = n_cols - 1
        logs_h = n_rows - (header_h + jobs_h + dirs_h)

        try:
            header_win = curses.newwin(header_h, n_cols, header_pos, 0)
            log_win = curses.newwin(logs_h, n_cols, logscreen_pos, 0)
            jobs_win = curses.newwin(jobs_h, n_cols, jobs_pos, 0)
            dirs_win = curses.newwin(dirs_h, n_cols, dirs_pos, 0)
        except Exception:
            raise Exception(&#39;Failed to initialize curses windows, try a larger &#39;
                            &#39;terminal window.&#39;)

        #
        # Write
        #

        # Header
        header_win.addnstr(0, 0, &#39;Plotman&#39;, linecap, curses.A_BOLD)
        timestamp = datetime.datetime.now().strftime(&#34;%H:%M:%S&#34;)
        refresh_msg = &#34;now&#34; if do_full_refresh else f&#34;{int(elapsed)}s/{cfg.scheduling.polling_time_s}&#34;
        header_win.addnstr(f&#34; {timestamp} (refresh {refresh_msg})&#34;, linecap)
        header_win.addnstr(&#39;  |  &lt;P&gt;lotting: &#39;, linecap, curses.A_BOLD)
        header_win.addnstr(
            plotting_status_msg(plotting_active, plotting_status), linecap)
        header_win.addnstr(&#39; &lt;A&gt;rchival: &#39;, linecap, curses.A_BOLD)
        header_win.addnstr(
            archiving_status_msg(archiving_configured,
                                 archiving_active, archiving_status), linecap)

        # Oneliner progress display
        header_win.addnstr(1, 0, &#39;Jobs (%d): &#39; % len(jobs), linecap)
        header_win.addnstr(&#39;[&#39; + reporting.job_viz(jobs) + &#39;]&#39;, linecap)

        # These are useful for debugging.
        # header_win.addnstr(&#39;  term size: (%d, %d)&#39; % (n_rows, n_cols), linecap)  # Debuggin
        # if pressed_key:
        # header_win.addnstr(&#39; (keypress %s)&#39; % str(pressed_key), linecap)
        header_win.addnstr(2, 0, &#39;Prefixes:&#39;, linecap, curses.A_BOLD)
        header_win.addnstr(&#39;  tmp=&#39;, linecap, curses.A_BOLD)
        header_win.addnstr(tmp_prefix, linecap)
        header_win.addnstr(&#39;  dst=&#39;, linecap, curses.A_BOLD)
        header_win.addnstr(dst_prefix, linecap)
        if archiving_configured:
            header_win.addnstr(&#39;  archive=&#39;, linecap, curses.A_BOLD)
            header_win.addnstr(arch_prefix, linecap)
        header_win.addnstr(&#39; (remote)&#39;, linecap)

        # Jobs
        jobs_win.addstr(0, 0, reporting.status_report(jobs, n_cols, jobs_h,
                                                      tmp_prefix, dst_prefix))
        jobs_win.chgat(0, 0, curses.A_REVERSE)

        # Dirs
        tmpwin_12_gutter = 3
        tmpwin_dstwin_gutter = 6

        maxtd_h = max([tmp_h, dst_h])

        tmpwin_1 = curses.newwin(
            tmp_h, tmp_w,
            dirs_pos + int((maxtd_h - tmp_h) / 2), 0)
        tmpwin_1.addstr(tmp_report_1)

        tmpwin_2 = curses.newwin(
            tmp_h, tmp_w,
            dirs_pos + int((maxtd_h - tmp_h) / 2),
            tmp_w + tmpwin_12_gutter)
        tmpwin_2.addstr(tmp_report_2)

        tmpwin_1.chgat(0, 0, curses.A_REVERSE)
        tmpwin_2.chgat(0, 0, curses.A_REVERSE)

        dstwin = curses.newwin(
            dst_h, dst_w,
            dirs_pos + int((maxtd_h - dst_h) / 2), 2 * tmp_w + tmpwin_12_gutter + tmpwin_dstwin_gutter)
        dstwin.addstr(dst_report)
        dstwin.chgat(0, 0, curses.A_REVERSE)

        archwin = curses.newwin(arch_h, arch_w, dirs_pos + maxtd_h, 0)
        archwin.addstr(0, 0, &#39;Archive dirs free space&#39;, curses.A_REVERSE)
        archwin.addstr(1, 0, arch_report)

        # Log.  Could use a pad here instead of managing scrolling ourselves, but
        # this seems easier.
        log_win.addnstr(0, 0, (&#39;Log: %d (&lt;up&gt;/&lt;down&gt;/&lt;end&gt; to scroll)\n&#39; % log.get_cur_pos()),
                        linecap, curses.A_REVERSE)
        for i, logline in enumerate(log.cur_slice(logs_h - 1)):
            log_win.addnstr(i + 1, 0, logline, linecap)

        stdscr.noutrefresh()
        header_win.noutrefresh()
        jobs_win.noutrefresh()
        tmpwin_1.noutrefresh()
        tmpwin_2.noutrefresh()
        dstwin.noutrefresh()
        archwin.noutrefresh()
        log_win.noutrefresh()
        curses.doupdate()

        try:
            key = stdscr.getch()
        except KeyboardInterrupt:
            key = ord(&#39;q&#39;)

        if key == curses.KEY_UP:
            log.shift_slice(-1)
            pressed_key = &#39;up&#39;
        elif key == curses.KEY_DOWN:
            log.shift_slice(1)
            pressed_key = &#39;dwn&#39;
        elif key == curses.KEY_END:
            log.shift_slice_to_end()
            pressed_key = &#39;end&#39;
        elif key == ord(&#39;p&#39;):
            plotting_active = not plotting_active
            pressed_key = &#39;p&#39;
        elif key == ord(&#39;a&#39;):
            archiving_active = not archiving_active
            pressed_key = &#39;a&#39;
        elif key == ord(&#39;q&#39;):
            break
        else:
            pressed_key = key</code></pre>
</details>
</dd>
<dt id="plotman.interactive.plotting_status_msg"><code class="name flex">
<span>def <span class="ident">plotting_status_msg</span></span>(<span>active, status)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotting_status_msg(active, status):
    if active:
        return &#39;(active) &#39; + status
    else:
        return &#39;(inactive) &#39; + status</code></pre>
</details>
</dd>
<dt id="plotman.interactive.run_interactive"><code class="name flex">
<span>def <span class="ident">run_interactive</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_interactive():
    locale.setlocale(locale.LC_ALL, &#39;&#39;)
    code = locale.getpreferredencoding()
    # Then use code as the encoding for str.encode() calls.

    try:
        curses.wrapper(curses_main)
    except curses.error as e:
        raise TerminalTooSmallError(
            &#34;Your terminal may be too small, try making it bigger.&#34;,
        ) from e</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="plotman.interactive.Log"><code class="flex name class">
<span>class <span class="ident">Log</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Log:
    def __init__(self):
        self.entries = []
        self.cur_pos = 0

    # TODO: store timestamp as actual timestamp indexing the messages
    def log(self, msg):
        &#39;&#39;&#39;Log the message and scroll to the end of the log&#39;&#39;&#39;
        ts = datetime.datetime.now().strftime(&#39;%m-%d %H:%M:%S&#39;)
        self.entries.append(ts + &#39; &#39; + msg)
        self.cur_pos = len(self.entries)

    def tail(self, num_entries):
        &#39;&#39;&#39;Return the entries at the end of the log.  Consider cur_slice() instead.&#39;&#39;&#39;
        return self.entries[-num_entries:]

    def shift_slice(self, offset):
        &#39;&#39;&#39;Positive shifts towards end, negative shifts towards beginning&#39;&#39;&#39;
        self.cur_pos = max(0, min(len(self.entries), self.cur_pos + offset))

    def shift_slice_to_end(self):
        self.cur_pos = len(self.entries)

    def get_cur_pos(self):
        return self.cur_pos

    def cur_slice(self, num_entries):
        &#39;&#39;&#39;Return num_entries log entries up to the current slice position&#39;&#39;&#39;
        return self.entries[max(0, self.cur_pos - num_entries): self.cur_pos]

    def fill_log(self):
        &#39;&#39;&#39;Add a bunch of stuff to the log.  Useful for testing.&#39;&#39;&#39;
        for i in range(100):
            self.log(&#39;Log line %d&#39; % i)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="plotman.interactive.Log.cur_slice"><code class="name flex">
<span>def <span class="ident">cur_slice</span></span>(<span>self, num_entries)</span>
</code></dt>
<dd>
<div class="desc"><p>Return num_entries log entries up to the current slice position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cur_slice(self, num_entries):
    &#39;&#39;&#39;Return num_entries log entries up to the current slice position&#39;&#39;&#39;
    return self.entries[max(0, self.cur_pos - num_entries): self.cur_pos]</code></pre>
</details>
</dd>
<dt id="plotman.interactive.Log.fill_log"><code class="name flex">
<span>def <span class="ident">fill_log</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a bunch of stuff to the log.
Useful for testing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_log(self):
    &#39;&#39;&#39;Add a bunch of stuff to the log.  Useful for testing.&#39;&#39;&#39;
    for i in range(100):
        self.log(&#39;Log line %d&#39; % i)</code></pre>
</details>
</dd>
<dt id="plotman.interactive.Log.get_cur_pos"><code class="name flex">
<span>def <span class="ident">get_cur_pos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cur_pos(self):
    return self.cur_pos</code></pre>
</details>
</dd>
<dt id="plotman.interactive.Log.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Log the message and scroll to the end of the log</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, msg):
    &#39;&#39;&#39;Log the message and scroll to the end of the log&#39;&#39;&#39;
    ts = datetime.datetime.now().strftime(&#39;%m-%d %H:%M:%S&#39;)
    self.entries.append(ts + &#39; &#39; + msg)
    self.cur_pos = len(self.entries)</code></pre>
</details>
</dd>
<dt id="plotman.interactive.Log.shift_slice"><code class="name flex">
<span>def <span class="ident">shift_slice</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Positive shifts towards end, negative shifts towards beginning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift_slice(self, offset):
    &#39;&#39;&#39;Positive shifts towards end, negative shifts towards beginning&#39;&#39;&#39;
    self.cur_pos = max(0, min(len(self.entries), self.cur_pos + offset))</code></pre>
</details>
</dd>
<dt id="plotman.interactive.Log.shift_slice_to_end"><code class="name flex">
<span>def <span class="ident">shift_slice_to_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift_slice_to_end(self):
    self.cur_pos = len(self.entries)</code></pre>
</details>
</dd>
<dt id="plotman.interactive.Log.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, num_entries)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the entries at the end of the log.
Consider cur_slice() instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, num_entries):
    &#39;&#39;&#39;Return the entries at the end of the log.  Consider cur_slice() instead.&#39;&#39;&#39;
    return self.entries[-num_entries:]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="plotman.interactive.TerminalTooSmallError"><code class="flex name class">
<span>class <span class="ident">TerminalTooSmallError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TerminalTooSmallError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="plotman" href="index.html">plotman</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="plotman.interactive.archiving_status_msg" href="#plotman.interactive.archiving_status_msg">archiving_status_msg</a></code></li>
<li><code><a title="plotman.interactive.curses_main" href="#plotman.interactive.curses_main">curses_main</a></code></li>
<li><code><a title="plotman.interactive.plotting_status_msg" href="#plotman.interactive.plotting_status_msg">plotting_status_msg</a></code></li>
<li><code><a title="plotman.interactive.run_interactive" href="#plotman.interactive.run_interactive">run_interactive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="plotman.interactive.Log" href="#plotman.interactive.Log">Log</a></code></h4>
<ul class="two-column">
<li><code><a title="plotman.interactive.Log.cur_slice" href="#plotman.interactive.Log.cur_slice">cur_slice</a></code></li>
<li><code><a title="plotman.interactive.Log.fill_log" href="#plotman.interactive.Log.fill_log">fill_log</a></code></li>
<li><code><a title="plotman.interactive.Log.get_cur_pos" href="#plotman.interactive.Log.get_cur_pos">get_cur_pos</a></code></li>
<li><code><a title="plotman.interactive.Log.log" href="#plotman.interactive.Log.log">log</a></code></li>
<li><code><a title="plotman.interactive.Log.shift_slice" href="#plotman.interactive.Log.shift_slice">shift_slice</a></code></li>
<li><code><a title="plotman.interactive.Log.shift_slice_to_end" href="#plotman.interactive.Log.shift_slice_to_end">shift_slice_to_end</a></code></li>
<li><code><a title="plotman.interactive.Log.tail" href="#plotman.interactive.Log.tail">tail</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="plotman.interactive.TerminalTooSmallError" href="#plotman.interactive.TerminalTooSmallError">TerminalTooSmallError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>