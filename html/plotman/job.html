<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>plotman.job API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>plotman.job</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># TODO do we use all these?
import contextlib
import os
import re
import time
from datetime import datetime

import pendulum
import psutil


def job_phases_for_tmpdir(d, all_jobs):
    &#39;&#39;&#39;Return phase 2-tuples for jobs running on tmpdir d&#39;&#39;&#39;
    return sorted([j.progress() for j in all_jobs if j.tmpdir == d])


def job_phases_for_dstdir(d, all_jobs):
    &#39;&#39;&#39;Return phase 2-tuples for jobs outputting to dstdir d&#39;&#39;&#39;
    return sorted([j.progress() for j in all_jobs if j.dstdir == d])


def is_plotting_cmdline(cmdline):
    return (
            len(cmdline) &gt;= 4
            and &#39;python&#39; in cmdline[0]
            and cmdline[1].endswith(&#39;/chia&#39;)
            and &#39;plots&#39; == cmdline[2]
            and &#39;create&#39; == cmdline[3]
    )


# This is a cmdline argument fix for https://github.com/ericaltendorf/plotman/issues/41
def cmdline_argfix(cmdline):
    known_keys = &#39;krbut2dne&#39;
    for i in cmdline:
        # If the argument starts with dash and a known key and is longer than 2,
        # then an argument is passed with no space between its key and value.
        # This is POSIX compliant but the arg parser was tripping over it.
        # In these cases, splitting that item up in separate key and value
        # elements results in a `cmdline` list that is correctly formatted.
        if i[0] == &#39;-&#39; and i[1] in known_keys and len(i) &gt; 2:
            yield i[0:2]  # key
            yield i[2:]  # value
        else:
            yield i


def parse_chia_plot_time(s):
    # This will grow to try ISO8601 as well for when Chia logs that way
    return pendulum.from_format(s, &#39;ddd MMM DD HH:mm:ss YYYY&#39;, locale=&#39;en&#39;, tz=None)


# TODO: be more principled and explicit about what we cache vs. what we look up
# dynamically from the logfile
class Job:
    &#39;Represents a plotter job&#39;

    # These are constants, not updated during a run.
    k = 0
    r = 0
    u = 0
    b = 0
    n = 0  # probably not used
    tmpdir = &#39;&#39;
    tmp2dir = &#39;&#39;
    dstdir = &#39;&#39;
    logfile = &#39;&#39;
    jobfile = &#39;&#39;
    job_id = 0
    plot_id = &#39;--------&#39;
    proc = None  # will get a psutil.Process
    help = False

    # These are dynamic, cached, and need to be udpated periodically
    phase = (None, None)  # Phase/subphase

    def get_running_jobs(logroot, cached_jobs=()):
        &#39;&#39;&#39;Return a list of running plot jobs.  If a cache of preexisting jobs is provided,
           reuse those previous jobs without updating their information.  Always look for
           new jobs not already in the cache.&#39;&#39;&#39;
        jobs = []
        cached_jobs_by_pid = {j.proc.pid: j for j in cached_jobs}

        for proc in psutil.process_iter([&#39;pid&#39;, &#39;cmdline&#39;]):
            # Ignore processes which most likely have terminated between the time of
            # iteration and data access.
            with contextlib.suppress(psutil.NoSuchProcess, psutil.AccessDenied):
                if is_plotting_cmdline(proc.cmdline()):
                    if proc.pid in cached_jobs_by_pid.keys():
                        jobs.append(cached_jobs_by_pid[proc.pid])  # Copy from cache
                    else:
                        job = Job(proc, logroot)
                        if not job.help:
                            jobs.append(job)

        return jobs

    def __init__(self, proc, logroot):
        &#39;&#39;&#39;Initialize from an existing psutil.Process object.  must know logroot in order to understand open files&#39;&#39;&#39;
        self.proc = proc

        with self.proc.oneshot():
            # Parse command line args
            args = self.proc.cmdline()
            assert len(args) &gt; 4
            assert &#39;python&#39; in args[0]
            assert &#39;chia&#39; in args[1]
            assert &#39;plots&#39; == args[2]
            assert &#39;create&#39; == args[3]
            args_iter = iter(cmdline_argfix(args[4:]))
            for arg in args_iter:
                val = None if arg in {&#39;-e&#39;, &#39;--nobitfield&#39;, &#39;-h&#39;, &#39;--help&#39;, &#39;--override-k&#39;} else next(args_iter)
                if arg in {&#39;-k&#39;, &#39;--size&#39;}:
                    self.k = val
                elif arg in {&#39;-r&#39;, &#39;--num_threads&#39;}:
                    self.r = val
                elif arg in {&#39;-b&#39;, &#39;--buffer&#39;}:
                    self.b = val
                elif arg in {&#39;-u&#39;, &#39;--buckets&#39;}:
                    self.u = val
                elif arg in {&#39;-t&#39;, &#39;--tmp_dir&#39;}:
                    self.tmpdir = val
                elif arg in {&#39;-2&#39;, &#39;--tmp2_dir&#39;}:
                    self.tmp2dir = val
                elif arg in {&#39;-d&#39;, &#39;--final_dir&#39;}:
                    self.dstdir = val
                elif arg in {&#39;-n&#39;, &#39;--num&#39;}:
                    self.n = val
                elif arg in {&#39;-h&#39;, &#39;--help&#39;}:
                    self.help = True
                elif arg in {&#39;-e&#39;, &#39;--nobitfield&#39;, &#39;-f&#39;, &#39;--farmer_public_key&#39;, &#39;-p&#39;, &#39;--pool_public_key&#39;}:
                    pass
                    # TODO: keep track of these
                elif arg == &#39;--override-k&#39;:
                    pass
                else:
                    print(&#39;Warning: unrecognized args: %s %s&#39; % (arg, val))

            # Find logfile (whatever file is open under the log root).  The
            # file may be open more than once, e.g. for STDOUT and STDERR.
            for f in self.proc.open_files():
                if logroot in f.path:
                    if self.logfile:
                        assert self.logfile == f.path
                    else:
                        self.logfile = f.path
                    break

            if self.logfile:
                # Initialize data that needs to be loaded from the logfile
                self.init_from_logfile()
            else:
                print(&#39;Found plotting process PID {pid}, but could not find &#39;
                      &#39;logfile in its open files:&#39;.format(pid=self.proc.pid))
                for f in self.proc.open_files():
                    print(f.path)

    def init_from_logfile(self):
        &#34;&#34;&#34;
        Read plot ID and job start time from logfile.  Return true if we
           find all the info as expected, false otherwise
        &#34;&#34;&#34;

        assert self.logfile
        # Try reading for a while; it can take a while for the job to get started as it scans
        # existing plot dirs (especially if they are NFS).
        found_id = False
        found_log = False
        for attempt_number in range(3):
            with open(self.logfile, &#39;r&#39;) as f:
                for line in f:
                    m = re.match(&#39;^ID: ([0-9a-f]*)&#39;, line)
                    if m:
                        self.plot_id = m.group(1)
                        found_id = True
                    m = re.match(r&#39;^Starting phase 1/4:.*\.\.\. (.*)&#39;, line)
                    if m:
                        # Mon Nov  2 08:39:53 2020
                        self.start_time = parse_chia_plot_time(m.group(1))
                        found_log = True
                        break  # Stop reading lines in file

            if found_id and found_log:
                break  # Stop trying
            else:
                time.sleep(1)  # Sleep and try again

        # If we couldn&#39;t find the line in the logfile, the job is probably just getting started
        # (and being slow about it).  In this case, use the last metadata change as the start time.
        # TODO: we never come back to this; e.g. plot_id may remain uninitialized.
        # TODO: should we just use the process start time instead?
        if not found_log:
            self.start_time = datetime.fromtimestamp(os.path.getctime(self.logfile))

        # Load things from logfile that are dynamic
        self.update_from_logfile()

    def update_from_logfile(self):
        self.set_phase_from_logfile()

    def set_phase_from_logfile(self):
        assert self.logfile

        # Map from phase number to subphase number reached in that phase.
        # Phase 1 subphases are &lt;started&gt;, table1, table2, ...
        # Phase 2 subphases are &lt;started&gt;, table7, table6, ...
        # Phase 3 subphases are &lt;started&gt;, tables1&amp;2, tables2&amp;3, ...
        # Phase 4 subphases are &lt;started&gt;
        phase_subphases = {}

        with open(self.logfile, &#39;r&#39;) as f:
            for line in f:
                # &#34;Starting phase 1/4: Forward Propagation into tmp files... Sat Oct 31 11:27:04 2020&#34;
                m = re.match(r&#39;^Starting phase (\d).*&#39;, line)
                if m:
                    phase = int(m.group(1))
                    phase_subphases[phase] = 0

                # Phase 1: &#34;Computing table 2&#34;
                m = re.match(r&#39;^Computing table (\d).*&#39;, line)
                if m:
                    phase_subphases[1] = max(phase_subphases[1], int(m.group(1)))

                # Phase 2: &#34;Backpropagating on table 2&#34;
                m = re.match(r&#39;^Backpropagating on table (\d).*&#39;, line)
                if m:
                    phase_subphases[2] = max(phase_subphases[2], 7 - int(m.group(1)))

                # Phase 3: &#34;Compressing tables 4 and 5&#34;
                m = re.match(r&#39;^Compressing tables (\d) and (\d).*&#39;, line)
                if m:
                    phase_subphases[3] = max(phase_subphases[3], int(m.group(1)))

                # TODO also collect timing info:

                # &#34;Time for phase 1 = 22796.7 seconds. CPU (98%) Tue Sep 29 17:57:19 2020&#34;
                # for phase in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]:
                # m = re.match(r&#39;^Time for phase &#39; + phase + &#39; = (\d+.\d+) seconds..*&#39;, line)
                # data.setdefault....

                # Total time = 49487.1 seconds. CPU (97.26%) Wed Sep 30 01:22:10 2020
                # m = re.match(r&#39;^Total time = (\d+.\d+) seconds.*&#39;, line)
                # if m:
                # data.setdefault(key, {}).setdefault(&#39;total time&#39;, []).append(float(m.group(1)))

        if phase_subphases:
            phase = max(phase_subphases.keys())
            self.phase = (phase, phase_subphases[phase])
        else:
            self.phase = (0, 0)

    def progress(self):
        &#39;&#39;&#39;Return a 2-tuple with the job phase and subphase (by reading the logfile)&#39;&#39;&#39;
        return self.phase

    def plot_id_prefix(self):
        return self.plot_id[:8]

    # TODO: make this more useful and complete, and/or make it configurable
    def status_str_long(self):
        return &#39;{plot_id}\nk={k} r={r} b={b} u={u}\npid:{pid}\ntmp:{tmp}\ntmp2:{tmp2}\ndst:{dst}\nlogfile:{logfile}&#39;.format(
            plot_id=self.plot_id,
            k=self.k,
            r=self.r,
            b=self.b,
            u=self.u,
            pid=self.proc.pid,
            tmp=self.tmpdir,
            tmp2=self.tmp2dir,
            dst=self.dstdir,
            plotid=self.plot_id,
            logfile=self.logfile
        )

    def get_mem_usage(self):
        return self.proc.memory_info().vms  # Total, inc swapped

    def get_tmp_usage(self):
        total_bytes = 0
        with os.scandir(self.tmpdir) as it:
            for entry in it:
                if self.plot_id in entry.name:
                    try:
                        total_bytes += entry.stat().st_size
                    except FileNotFoundError:
                        # The file might disappear; this being an estimate we don&#39;t care
                        pass
        return total_bytes

    def get_run_status(self):
        &#39;&#39;&#39;Running, suspended, etc.&#39;&#39;&#39;
        status = self.proc.status()
        if status == psutil.STATUS_RUNNING:
            return &#39;RUN&#39;
        elif status == psutil.STATUS_SLEEPING:
            return &#39;SLP&#39;
        elif status == psutil.STATUS_DISK_SLEEP:
            return &#39;DSK&#39;
        elif status == psutil.STATUS_STOPPED:
            return &#39;STP&#39;
        else:
            return self.proc.status()

    def get_time_wall(self):
        create_time = datetime.fromtimestamp(self.proc.create_time())
        return int((datetime.now() - create_time).total_seconds())

    def get_time_user(self):
        return int(self.proc.cpu_times().user)

    def get_time_sys(self):
        return int(self.proc.cpu_times().system)

    def get_time_iowait(self):
        cpu_times = self.proc.cpu_times()
        iowait = getattr(cpu_times, &#39;iowait&#39;, None)
        if iowait is None:
            return None

        return int(iowait)

    def suspend(self, reason=&#39;&#39;):
        self.proc.suspend()
        self.status_note = reason

    def resume(self):
        self.proc.resume()

    def get_temp_files(self):
        # Prevent duplicate file paths by using set.
        temp_files = set([])
        for f in self.proc.open_files():
            if self.tmpdir in f.path or self.tmp2dir in f.path or self.dstdir in f.path:
                temp_files.add(f.path)
        return temp_files

    def cancel(self):
        &#39;Cancel an already running job&#39;
        # We typically suspend the job as the first action in killing it, so it
        # doesn&#39;t create more tmp files during death.  However, terminate() won&#39;t
        # complete if the job is supsended, so we also need to resume it.
        # TODO: check that this is best practice for killing a job.
        self.proc.resume()
        self.proc.terminate()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="plotman.job.cmdline_argfix"><code class="name flex">
<span>def <span class="ident">cmdline_argfix</span></span>(<span>cmdline)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmdline_argfix(cmdline):
    known_keys = &#39;krbut2dne&#39;
    for i in cmdline:
        # If the argument starts with dash and a known key and is longer than 2,
        # then an argument is passed with no space between its key and value.
        # This is POSIX compliant but the arg parser was tripping over it.
        # In these cases, splitting that item up in separate key and value
        # elements results in a `cmdline` list that is correctly formatted.
        if i[0] == &#39;-&#39; and i[1] in known_keys and len(i) &gt; 2:
            yield i[0:2]  # key
            yield i[2:]  # value
        else:
            yield i</code></pre>
</details>
</dd>
<dt id="plotman.job.is_plotting_cmdline"><code class="name flex">
<span>def <span class="ident">is_plotting_cmdline</span></span>(<span>cmdline)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_plotting_cmdline(cmdline):
    return (
            len(cmdline) &gt;= 4
            and &#39;python&#39; in cmdline[0]
            and cmdline[1].endswith(&#39;/chia&#39;)
            and &#39;plots&#39; == cmdline[2]
            and &#39;create&#39; == cmdline[3]
    )</code></pre>
</details>
</dd>
<dt id="plotman.job.job_phases_for_dstdir"><code class="name flex">
<span>def <span class="ident">job_phases_for_dstdir</span></span>(<span>d, all_jobs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return phase 2-tuples for jobs outputting to dstdir d</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def job_phases_for_dstdir(d, all_jobs):
    &#39;&#39;&#39;Return phase 2-tuples for jobs outputting to dstdir d&#39;&#39;&#39;
    return sorted([j.progress() for j in all_jobs if j.dstdir == d])</code></pre>
</details>
</dd>
<dt id="plotman.job.job_phases_for_tmpdir"><code class="name flex">
<span>def <span class="ident">job_phases_for_tmpdir</span></span>(<span>d, all_jobs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return phase 2-tuples for jobs running on tmpdir d</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def job_phases_for_tmpdir(d, all_jobs):
    &#39;&#39;&#39;Return phase 2-tuples for jobs running on tmpdir d&#39;&#39;&#39;
    return sorted([j.progress() for j in all_jobs if j.tmpdir == d])</code></pre>
</details>
</dd>
<dt id="plotman.job.parse_chia_plot_time"><code class="name flex">
<span>def <span class="ident">parse_chia_plot_time</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_chia_plot_time(s):
    # This will grow to try ISO8601 as well for when Chia logs that way
    return pendulum.from_format(s, &#39;ddd MMM DD HH:mm:ss YYYY&#39;, locale=&#39;en&#39;, tz=None)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="plotman.job.Job"><code class="flex name class">
<span>class <span class="ident">Job</span></span>
<span>(</span><span>proc, logroot)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a plotter job</p>
<p>Initialize from an existing psutil.Process object.
must know logroot in order to understand open files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Job:
    &#39;Represents a plotter job&#39;

    # These are constants, not updated during a run.
    k = 0
    r = 0
    u = 0
    b = 0
    n = 0  # probably not used
    tmpdir = &#39;&#39;
    tmp2dir = &#39;&#39;
    dstdir = &#39;&#39;
    logfile = &#39;&#39;
    jobfile = &#39;&#39;
    job_id = 0
    plot_id = &#39;--------&#39;
    proc = None  # will get a psutil.Process
    help = False

    # These are dynamic, cached, and need to be udpated periodically
    phase = (None, None)  # Phase/subphase

    def get_running_jobs(logroot, cached_jobs=()):
        &#39;&#39;&#39;Return a list of running plot jobs.  If a cache of preexisting jobs is provided,
           reuse those previous jobs without updating their information.  Always look for
           new jobs not already in the cache.&#39;&#39;&#39;
        jobs = []
        cached_jobs_by_pid = {j.proc.pid: j for j in cached_jobs}

        for proc in psutil.process_iter([&#39;pid&#39;, &#39;cmdline&#39;]):
            # Ignore processes which most likely have terminated between the time of
            # iteration and data access.
            with contextlib.suppress(psutil.NoSuchProcess, psutil.AccessDenied):
                if is_plotting_cmdline(proc.cmdline()):
                    if proc.pid in cached_jobs_by_pid.keys():
                        jobs.append(cached_jobs_by_pid[proc.pid])  # Copy from cache
                    else:
                        job = Job(proc, logroot)
                        if not job.help:
                            jobs.append(job)

        return jobs

    def __init__(self, proc, logroot):
        &#39;&#39;&#39;Initialize from an existing psutil.Process object.  must know logroot in order to understand open files&#39;&#39;&#39;
        self.proc = proc

        with self.proc.oneshot():
            # Parse command line args
            args = self.proc.cmdline()
            assert len(args) &gt; 4
            assert &#39;python&#39; in args[0]
            assert &#39;chia&#39; in args[1]
            assert &#39;plots&#39; == args[2]
            assert &#39;create&#39; == args[3]
            args_iter = iter(cmdline_argfix(args[4:]))
            for arg in args_iter:
                val = None if arg in {&#39;-e&#39;, &#39;--nobitfield&#39;, &#39;-h&#39;, &#39;--help&#39;, &#39;--override-k&#39;} else next(args_iter)
                if arg in {&#39;-k&#39;, &#39;--size&#39;}:
                    self.k = val
                elif arg in {&#39;-r&#39;, &#39;--num_threads&#39;}:
                    self.r = val
                elif arg in {&#39;-b&#39;, &#39;--buffer&#39;}:
                    self.b = val
                elif arg in {&#39;-u&#39;, &#39;--buckets&#39;}:
                    self.u = val
                elif arg in {&#39;-t&#39;, &#39;--tmp_dir&#39;}:
                    self.tmpdir = val
                elif arg in {&#39;-2&#39;, &#39;--tmp2_dir&#39;}:
                    self.tmp2dir = val
                elif arg in {&#39;-d&#39;, &#39;--final_dir&#39;}:
                    self.dstdir = val
                elif arg in {&#39;-n&#39;, &#39;--num&#39;}:
                    self.n = val
                elif arg in {&#39;-h&#39;, &#39;--help&#39;}:
                    self.help = True
                elif arg in {&#39;-e&#39;, &#39;--nobitfield&#39;, &#39;-f&#39;, &#39;--farmer_public_key&#39;, &#39;-p&#39;, &#39;--pool_public_key&#39;}:
                    pass
                    # TODO: keep track of these
                elif arg == &#39;--override-k&#39;:
                    pass
                else:
                    print(&#39;Warning: unrecognized args: %s %s&#39; % (arg, val))

            # Find logfile (whatever file is open under the log root).  The
            # file may be open more than once, e.g. for STDOUT and STDERR.
            for f in self.proc.open_files():
                if logroot in f.path:
                    if self.logfile:
                        assert self.logfile == f.path
                    else:
                        self.logfile = f.path
                    break

            if self.logfile:
                # Initialize data that needs to be loaded from the logfile
                self.init_from_logfile()
            else:
                print(&#39;Found plotting process PID {pid}, but could not find &#39;
                      &#39;logfile in its open files:&#39;.format(pid=self.proc.pid))
                for f in self.proc.open_files():
                    print(f.path)

    def init_from_logfile(self):
        &#34;&#34;&#34;
        Read plot ID and job start time from logfile.  Return true if we
           find all the info as expected, false otherwise
        &#34;&#34;&#34;

        assert self.logfile
        # Try reading for a while; it can take a while for the job to get started as it scans
        # existing plot dirs (especially if they are NFS).
        found_id = False
        found_log = False
        for attempt_number in range(3):
            with open(self.logfile, &#39;r&#39;) as f:
                for line in f:
                    m = re.match(&#39;^ID: ([0-9a-f]*)&#39;, line)
                    if m:
                        self.plot_id = m.group(1)
                        found_id = True
                    m = re.match(r&#39;^Starting phase 1/4:.*\.\.\. (.*)&#39;, line)
                    if m:
                        # Mon Nov  2 08:39:53 2020
                        self.start_time = parse_chia_plot_time(m.group(1))
                        found_log = True
                        break  # Stop reading lines in file

            if found_id and found_log:
                break  # Stop trying
            else:
                time.sleep(1)  # Sleep and try again

        # If we couldn&#39;t find the line in the logfile, the job is probably just getting started
        # (and being slow about it).  In this case, use the last metadata change as the start time.
        # TODO: we never come back to this; e.g. plot_id may remain uninitialized.
        # TODO: should we just use the process start time instead?
        if not found_log:
            self.start_time = datetime.fromtimestamp(os.path.getctime(self.logfile))

        # Load things from logfile that are dynamic
        self.update_from_logfile()

    def update_from_logfile(self):
        self.set_phase_from_logfile()

    def set_phase_from_logfile(self):
        assert self.logfile

        # Map from phase number to subphase number reached in that phase.
        # Phase 1 subphases are &lt;started&gt;, table1, table2, ...
        # Phase 2 subphases are &lt;started&gt;, table7, table6, ...
        # Phase 3 subphases are &lt;started&gt;, tables1&amp;2, tables2&amp;3, ...
        # Phase 4 subphases are &lt;started&gt;
        phase_subphases = {}

        with open(self.logfile, &#39;r&#39;) as f:
            for line in f:
                # &#34;Starting phase 1/4: Forward Propagation into tmp files... Sat Oct 31 11:27:04 2020&#34;
                m = re.match(r&#39;^Starting phase (\d).*&#39;, line)
                if m:
                    phase = int(m.group(1))
                    phase_subphases[phase] = 0

                # Phase 1: &#34;Computing table 2&#34;
                m = re.match(r&#39;^Computing table (\d).*&#39;, line)
                if m:
                    phase_subphases[1] = max(phase_subphases[1], int(m.group(1)))

                # Phase 2: &#34;Backpropagating on table 2&#34;
                m = re.match(r&#39;^Backpropagating on table (\d).*&#39;, line)
                if m:
                    phase_subphases[2] = max(phase_subphases[2], 7 - int(m.group(1)))

                # Phase 3: &#34;Compressing tables 4 and 5&#34;
                m = re.match(r&#39;^Compressing tables (\d) and (\d).*&#39;, line)
                if m:
                    phase_subphases[3] = max(phase_subphases[3], int(m.group(1)))

                # TODO also collect timing info:

                # &#34;Time for phase 1 = 22796.7 seconds. CPU (98%) Tue Sep 29 17:57:19 2020&#34;
                # for phase in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]:
                # m = re.match(r&#39;^Time for phase &#39; + phase + &#39; = (\d+.\d+) seconds..*&#39;, line)
                # data.setdefault....

                # Total time = 49487.1 seconds. CPU (97.26%) Wed Sep 30 01:22:10 2020
                # m = re.match(r&#39;^Total time = (\d+.\d+) seconds.*&#39;, line)
                # if m:
                # data.setdefault(key, {}).setdefault(&#39;total time&#39;, []).append(float(m.group(1)))

        if phase_subphases:
            phase = max(phase_subphases.keys())
            self.phase = (phase, phase_subphases[phase])
        else:
            self.phase = (0, 0)

    def progress(self):
        &#39;&#39;&#39;Return a 2-tuple with the job phase and subphase (by reading the logfile)&#39;&#39;&#39;
        return self.phase

    def plot_id_prefix(self):
        return self.plot_id[:8]

    # TODO: make this more useful and complete, and/or make it configurable
    def status_str_long(self):
        return &#39;{plot_id}\nk={k} r={r} b={b} u={u}\npid:{pid}\ntmp:{tmp}\ntmp2:{tmp2}\ndst:{dst}\nlogfile:{logfile}&#39;.format(
            plot_id=self.plot_id,
            k=self.k,
            r=self.r,
            b=self.b,
            u=self.u,
            pid=self.proc.pid,
            tmp=self.tmpdir,
            tmp2=self.tmp2dir,
            dst=self.dstdir,
            plotid=self.plot_id,
            logfile=self.logfile
        )

    def get_mem_usage(self):
        return self.proc.memory_info().vms  # Total, inc swapped

    def get_tmp_usage(self):
        total_bytes = 0
        with os.scandir(self.tmpdir) as it:
            for entry in it:
                if self.plot_id in entry.name:
                    try:
                        total_bytes += entry.stat().st_size
                    except FileNotFoundError:
                        # The file might disappear; this being an estimate we don&#39;t care
                        pass
        return total_bytes

    def get_run_status(self):
        &#39;&#39;&#39;Running, suspended, etc.&#39;&#39;&#39;
        status = self.proc.status()
        if status == psutil.STATUS_RUNNING:
            return &#39;RUN&#39;
        elif status == psutil.STATUS_SLEEPING:
            return &#39;SLP&#39;
        elif status == psutil.STATUS_DISK_SLEEP:
            return &#39;DSK&#39;
        elif status == psutil.STATUS_STOPPED:
            return &#39;STP&#39;
        else:
            return self.proc.status()

    def get_time_wall(self):
        create_time = datetime.fromtimestamp(self.proc.create_time())
        return int((datetime.now() - create_time).total_seconds())

    def get_time_user(self):
        return int(self.proc.cpu_times().user)

    def get_time_sys(self):
        return int(self.proc.cpu_times().system)

    def get_time_iowait(self):
        cpu_times = self.proc.cpu_times()
        iowait = getattr(cpu_times, &#39;iowait&#39;, None)
        if iowait is None:
            return None

        return int(iowait)

    def suspend(self, reason=&#39;&#39;):
        self.proc.suspend()
        self.status_note = reason

    def resume(self):
        self.proc.resume()

    def get_temp_files(self):
        # Prevent duplicate file paths by using set.
        temp_files = set([])
        for f in self.proc.open_files():
            if self.tmpdir in f.path or self.tmp2dir in f.path or self.dstdir in f.path:
                temp_files.add(f.path)
        return temp_files

    def cancel(self):
        &#39;Cancel an already running job&#39;
        # We typically suspend the job as the first action in killing it, so it
        # doesn&#39;t create more tmp files during death.  However, terminate() won&#39;t
        # complete if the job is supsended, so we also need to resume it.
        # TODO: check that this is best practice for killing a job.
        self.proc.resume()
        self.proc.terminate()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="plotman.job.Job.b"><code class="name">var <span class="ident">b</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.dstdir"><code class="name">var <span class="ident">dstdir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.help"><code class="name">var <span class="ident">help</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.job_id"><code class="name">var <span class="ident">job_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.jobfile"><code class="name">var <span class="ident">jobfile</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.k"><code class="name">var <span class="ident">k</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.logfile"><code class="name">var <span class="ident">logfile</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.phase"><code class="name">var <span class="ident">phase</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.plot_id"><code class="name">var <span class="ident">plot_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.proc"><code class="name">var <span class="ident">proc</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.r"><code class="name">var <span class="ident">r</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.tmp2dir"><code class="name">var <span class="ident">tmp2dir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.tmpdir"><code class="name">var <span class="ident">tmpdir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="plotman.job.Job.u"><code class="name">var <span class="ident">u</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="plotman.job.Job.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel an already running job</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self):
    &#39;Cancel an already running job&#39;
    # We typically suspend the job as the first action in killing it, so it
    # doesn&#39;t create more tmp files during death.  However, terminate() won&#39;t
    # complete if the job is supsended, so we also need to resume it.
    # TODO: check that this is best practice for killing a job.
    self.proc.resume()
    self.proc.terminate()</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_mem_usage"><code class="name flex">
<span>def <span class="ident">get_mem_usage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mem_usage(self):
    return self.proc.memory_info().vms  # Total, inc swapped</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_run_status"><code class="name flex">
<span>def <span class="ident">get_run_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Running, suspended, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_run_status(self):
    &#39;&#39;&#39;Running, suspended, etc.&#39;&#39;&#39;
    status = self.proc.status()
    if status == psutil.STATUS_RUNNING:
        return &#39;RUN&#39;
    elif status == psutil.STATUS_SLEEPING:
        return &#39;SLP&#39;
    elif status == psutil.STATUS_DISK_SLEEP:
        return &#39;DSK&#39;
    elif status == psutil.STATUS_STOPPED:
        return &#39;STP&#39;
    else:
        return self.proc.status()</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_running_jobs"><code class="name flex">
<span>def <span class="ident">get_running_jobs</span></span>(<span>logroot, cached_jobs=())</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of running plot jobs.
If a cache of preexisting jobs is provided,
reuse those previous jobs without updating their information.
Always look for
new jobs not already in the cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_running_jobs(logroot, cached_jobs=()):
    &#39;&#39;&#39;Return a list of running plot jobs.  If a cache of preexisting jobs is provided,
       reuse those previous jobs without updating their information.  Always look for
       new jobs not already in the cache.&#39;&#39;&#39;
    jobs = []
    cached_jobs_by_pid = {j.proc.pid: j for j in cached_jobs}

    for proc in psutil.process_iter([&#39;pid&#39;, &#39;cmdline&#39;]):
        # Ignore processes which most likely have terminated between the time of
        # iteration and data access.
        with contextlib.suppress(psutil.NoSuchProcess, psutil.AccessDenied):
            if is_plotting_cmdline(proc.cmdline()):
                if proc.pid in cached_jobs_by_pid.keys():
                    jobs.append(cached_jobs_by_pid[proc.pid])  # Copy from cache
                else:
                    job = Job(proc, logroot)
                    if not job.help:
                        jobs.append(job)

    return jobs</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_temp_files"><code class="name flex">
<span>def <span class="ident">get_temp_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_temp_files(self):
    # Prevent duplicate file paths by using set.
    temp_files = set([])
    for f in self.proc.open_files():
        if self.tmpdir in f.path or self.tmp2dir in f.path or self.dstdir in f.path:
            temp_files.add(f.path)
    return temp_files</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_time_iowait"><code class="name flex">
<span>def <span class="ident">get_time_iowait</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_iowait(self):
    cpu_times = self.proc.cpu_times()
    iowait = getattr(cpu_times, &#39;iowait&#39;, None)
    if iowait is None:
        return None

    return int(iowait)</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_time_sys"><code class="name flex">
<span>def <span class="ident">get_time_sys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_sys(self):
    return int(self.proc.cpu_times().system)</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_time_user"><code class="name flex">
<span>def <span class="ident">get_time_user</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_user(self):
    return int(self.proc.cpu_times().user)</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_time_wall"><code class="name flex">
<span>def <span class="ident">get_time_wall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_wall(self):
    create_time = datetime.fromtimestamp(self.proc.create_time())
    return int((datetime.now() - create_time).total_seconds())</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.get_tmp_usage"><code class="name flex">
<span>def <span class="ident">get_tmp_usage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tmp_usage(self):
    total_bytes = 0
    with os.scandir(self.tmpdir) as it:
        for entry in it:
            if self.plot_id in entry.name:
                try:
                    total_bytes += entry.stat().st_size
                except FileNotFoundError:
                    # The file might disappear; this being an estimate we don&#39;t care
                    pass
    return total_bytes</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.init_from_logfile"><code class="name flex">
<span>def <span class="ident">init_from_logfile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read plot ID and job start time from logfile.
Return true if we
find all the info as expected, false otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_from_logfile(self):
    &#34;&#34;&#34;
    Read plot ID and job start time from logfile.  Return true if we
       find all the info as expected, false otherwise
    &#34;&#34;&#34;

    assert self.logfile
    # Try reading for a while; it can take a while for the job to get started as it scans
    # existing plot dirs (especially if they are NFS).
    found_id = False
    found_log = False
    for attempt_number in range(3):
        with open(self.logfile, &#39;r&#39;) as f:
            for line in f:
                m = re.match(&#39;^ID: ([0-9a-f]*)&#39;, line)
                if m:
                    self.plot_id = m.group(1)
                    found_id = True
                m = re.match(r&#39;^Starting phase 1/4:.*\.\.\. (.*)&#39;, line)
                if m:
                    # Mon Nov  2 08:39:53 2020
                    self.start_time = parse_chia_plot_time(m.group(1))
                    found_log = True
                    break  # Stop reading lines in file

        if found_id and found_log:
            break  # Stop trying
        else:
            time.sleep(1)  # Sleep and try again

    # If we couldn&#39;t find the line in the logfile, the job is probably just getting started
    # (and being slow about it).  In this case, use the last metadata change as the start time.
    # TODO: we never come back to this; e.g. plot_id may remain uninitialized.
    # TODO: should we just use the process start time instead?
    if not found_log:
        self.start_time = datetime.fromtimestamp(os.path.getctime(self.logfile))

    # Load things from logfile that are dynamic
    self.update_from_logfile()</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.plot_id_prefix"><code class="name flex">
<span>def <span class="ident">plot_id_prefix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_id_prefix(self):
    return self.plot_id[:8]</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.progress"><code class="name flex">
<span>def <span class="ident">progress</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a 2-tuple with the job phase and subphase (by reading the logfile)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress(self):
    &#39;&#39;&#39;Return a 2-tuple with the job phase and subphase (by reading the logfile)&#39;&#39;&#39;
    return self.phase</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.resume"><code class="name flex">
<span>def <span class="ident">resume</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resume(self):
    self.proc.resume()</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.set_phase_from_logfile"><code class="name flex">
<span>def <span class="ident">set_phase_from_logfile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_phase_from_logfile(self):
    assert self.logfile

    # Map from phase number to subphase number reached in that phase.
    # Phase 1 subphases are &lt;started&gt;, table1, table2, ...
    # Phase 2 subphases are &lt;started&gt;, table7, table6, ...
    # Phase 3 subphases are &lt;started&gt;, tables1&amp;2, tables2&amp;3, ...
    # Phase 4 subphases are &lt;started&gt;
    phase_subphases = {}

    with open(self.logfile, &#39;r&#39;) as f:
        for line in f:
            # &#34;Starting phase 1/4: Forward Propagation into tmp files... Sat Oct 31 11:27:04 2020&#34;
            m = re.match(r&#39;^Starting phase (\d).*&#39;, line)
            if m:
                phase = int(m.group(1))
                phase_subphases[phase] = 0

            # Phase 1: &#34;Computing table 2&#34;
            m = re.match(r&#39;^Computing table (\d).*&#39;, line)
            if m:
                phase_subphases[1] = max(phase_subphases[1], int(m.group(1)))

            # Phase 2: &#34;Backpropagating on table 2&#34;
            m = re.match(r&#39;^Backpropagating on table (\d).*&#39;, line)
            if m:
                phase_subphases[2] = max(phase_subphases[2], 7 - int(m.group(1)))

            # Phase 3: &#34;Compressing tables 4 and 5&#34;
            m = re.match(r&#39;^Compressing tables (\d) and (\d).*&#39;, line)
            if m:
                phase_subphases[3] = max(phase_subphases[3], int(m.group(1)))

            # TODO also collect timing info:

            # &#34;Time for phase 1 = 22796.7 seconds. CPU (98%) Tue Sep 29 17:57:19 2020&#34;
            # for phase in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]:
            # m = re.match(r&#39;^Time for phase &#39; + phase + &#39; = (\d+.\d+) seconds..*&#39;, line)
            # data.setdefault....

            # Total time = 49487.1 seconds. CPU (97.26%) Wed Sep 30 01:22:10 2020
            # m = re.match(r&#39;^Total time = (\d+.\d+) seconds.*&#39;, line)
            # if m:
            # data.setdefault(key, {}).setdefault(&#39;total time&#39;, []).append(float(m.group(1)))

    if phase_subphases:
        phase = max(phase_subphases.keys())
        self.phase = (phase, phase_subphases[phase])
    else:
        self.phase = (0, 0)</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.status_str_long"><code class="name flex">
<span>def <span class="ident">status_str_long</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status_str_long(self):
    return &#39;{plot_id}\nk={k} r={r} b={b} u={u}\npid:{pid}\ntmp:{tmp}\ntmp2:{tmp2}\ndst:{dst}\nlogfile:{logfile}&#39;.format(
        plot_id=self.plot_id,
        k=self.k,
        r=self.r,
        b=self.b,
        u=self.u,
        pid=self.proc.pid,
        tmp=self.tmpdir,
        tmp2=self.tmp2dir,
        dst=self.dstdir,
        plotid=self.plot_id,
        logfile=self.logfile
    )</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.suspend"><code class="name flex">
<span>def <span class="ident">suspend</span></span>(<span>self, reason='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suspend(self, reason=&#39;&#39;):
    self.proc.suspend()
    self.status_note = reason</code></pre>
</details>
</dd>
<dt id="plotman.job.Job.update_from_logfile"><code class="name flex">
<span>def <span class="ident">update_from_logfile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_from_logfile(self):
    self.set_phase_from_logfile()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="plotman" href="index.html">plotman</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="plotman.job.cmdline_argfix" href="#plotman.job.cmdline_argfix">cmdline_argfix</a></code></li>
<li><code><a title="plotman.job.is_plotting_cmdline" href="#plotman.job.is_plotting_cmdline">is_plotting_cmdline</a></code></li>
<li><code><a title="plotman.job.job_phases_for_dstdir" href="#plotman.job.job_phases_for_dstdir">job_phases_for_dstdir</a></code></li>
<li><code><a title="plotman.job.job_phases_for_tmpdir" href="#plotman.job.job_phases_for_tmpdir">job_phases_for_tmpdir</a></code></li>
<li><code><a title="plotman.job.parse_chia_plot_time" href="#plotman.job.parse_chia_plot_time">parse_chia_plot_time</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="plotman.job.Job" href="#plotman.job.Job">Job</a></code></h4>
<ul class="">
<li><code><a title="plotman.job.Job.b" href="#plotman.job.Job.b">b</a></code></li>
<li><code><a title="plotman.job.Job.cancel" href="#plotman.job.Job.cancel">cancel</a></code></li>
<li><code><a title="plotman.job.Job.dstdir" href="#plotman.job.Job.dstdir">dstdir</a></code></li>
<li><code><a title="plotman.job.Job.get_mem_usage" href="#plotman.job.Job.get_mem_usage">get_mem_usage</a></code></li>
<li><code><a title="plotman.job.Job.get_run_status" href="#plotman.job.Job.get_run_status">get_run_status</a></code></li>
<li><code><a title="plotman.job.Job.get_running_jobs" href="#plotman.job.Job.get_running_jobs">get_running_jobs</a></code></li>
<li><code><a title="plotman.job.Job.get_temp_files" href="#plotman.job.Job.get_temp_files">get_temp_files</a></code></li>
<li><code><a title="plotman.job.Job.get_time_iowait" href="#plotman.job.Job.get_time_iowait">get_time_iowait</a></code></li>
<li><code><a title="plotman.job.Job.get_time_sys" href="#plotman.job.Job.get_time_sys">get_time_sys</a></code></li>
<li><code><a title="plotman.job.Job.get_time_user" href="#plotman.job.Job.get_time_user">get_time_user</a></code></li>
<li><code><a title="plotman.job.Job.get_time_wall" href="#plotman.job.Job.get_time_wall">get_time_wall</a></code></li>
<li><code><a title="plotman.job.Job.get_tmp_usage" href="#plotman.job.Job.get_tmp_usage">get_tmp_usage</a></code></li>
<li><code><a title="plotman.job.Job.help" href="#plotman.job.Job.help">help</a></code></li>
<li><code><a title="plotman.job.Job.init_from_logfile" href="#plotman.job.Job.init_from_logfile">init_from_logfile</a></code></li>
<li><code><a title="plotman.job.Job.job_id" href="#plotman.job.Job.job_id">job_id</a></code></li>
<li><code><a title="plotman.job.Job.jobfile" href="#plotman.job.Job.jobfile">jobfile</a></code></li>
<li><code><a title="plotman.job.Job.k" href="#plotman.job.Job.k">k</a></code></li>
<li><code><a title="plotman.job.Job.logfile" href="#plotman.job.Job.logfile">logfile</a></code></li>
<li><code><a title="plotman.job.Job.n" href="#plotman.job.Job.n">n</a></code></li>
<li><code><a title="plotman.job.Job.phase" href="#plotman.job.Job.phase">phase</a></code></li>
<li><code><a title="plotman.job.Job.plot_id" href="#plotman.job.Job.plot_id">plot_id</a></code></li>
<li><code><a title="plotman.job.Job.plot_id_prefix" href="#plotman.job.Job.plot_id_prefix">plot_id_prefix</a></code></li>
<li><code><a title="plotman.job.Job.proc" href="#plotman.job.Job.proc">proc</a></code></li>
<li><code><a title="plotman.job.Job.progress" href="#plotman.job.Job.progress">progress</a></code></li>
<li><code><a title="plotman.job.Job.r" href="#plotman.job.Job.r">r</a></code></li>
<li><code><a title="plotman.job.Job.resume" href="#plotman.job.Job.resume">resume</a></code></li>
<li><code><a title="plotman.job.Job.set_phase_from_logfile" href="#plotman.job.Job.set_phase_from_logfile">set_phase_from_logfile</a></code></li>
<li><code><a title="plotman.job.Job.status_str_long" href="#plotman.job.Job.status_str_long">status_str_long</a></code></li>
<li><code><a title="plotman.job.Job.suspend" href="#plotman.job.Job.suspend">suspend</a></code></li>
<li><code><a title="plotman.job.Job.tmp2dir" href="#plotman.job.Job.tmp2dir">tmp2dir</a></code></li>
<li><code><a title="plotman.job.Job.tmpdir" href="#plotman.job.Job.tmpdir">tmpdir</a></code></li>
<li><code><a title="plotman.job.Job.u" href="#plotman.job.Job.u">u</a></code></li>
<li><code><a title="plotman.job.Job.update_from_logfile" href="#plotman.job.Job.update_from_logfile">update_from_logfile</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>